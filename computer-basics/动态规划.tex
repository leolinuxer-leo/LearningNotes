\documentclass[12pt]{article}
%\usepackage[utf8]{inputenc}
%\documentclass[UTF8]{ctexart}
%\usepackage[UTF8, heading = false, scheme = plain]{ctex}
\usepackage{geometry}
%geometry{a4paper,scale=0.9}
\geometry{a4paper,left=1cm,right=1cm,top=1cm,bottom=2cm}
\usepackage{amsfonts}
\usepackage{color}
\usepackage{url}
%\usepackage{biblatex}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{cite}
%\addbibresource{ref.bib}
%\bibliography{ref.bib}
\usepackage{caption}
\usepackage{graphicx, subfig}
\usepackage{float}
%\usepackage[fontset=ubuntu]{ctex}
%\usepackage{fontspec}
\usepackage{xeCJK}
%\usepackage[colorlinks,
%anchorcolor=black,
%citecolor=black]{hyperref}
%\setmainfont{SimSun}
\usepackage[section]{placeins}
\usepackage{enumitem}
\usepackage{framed}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{indentfirst}
\usepackage{setspace}%使用间距宏包
\linespread{1.5}
%\title{预备知识}
%\author{leolinuxer }
%\date{June 2020}

\begin{document}
%\maketitle

\section{动态规划的简单理解 \cite{Simple_DynamicProgramming}}

quora上有这样一个问题: How should I explain dynamic programming to a 4-year-old?

*writes down "1+1+1+1+1+1+1+1 =" on a sheet of paper*

"What's that equal to?"

*counting* "Eight!"

*writes down another "1+" on the left*

"What about that?"

*quickly* "Nine!"

"How'd you know it was nine so fast?"

"You just added one more"

"So you didn't need to recount because you remembered there were eight!Dynamic Programming is just a fancy way to say 'remembering stuff to save time later'"

动态规划是把大问题拆成若干个小问题；但是一个问题能否用动态规划求解的核心是：这些分拆后的小问题能不能被重复调用。

\textbf{简单理解就是：动态规划相当于递归算法，再加上记忆功能。}

\section{应用动态规划\cite{Simple_DynamicProgramming-2}}
如果一个问题满足以下两点，那么它就能用动态规划解决：

\begin{itemize}[itemindent=2em]
    \item 问题的答案依赖于问题的规模，也就是问题的所有答案构成了一个数列：$\{f(1),f(2), \cdots, f(n)\}$，其中 $n$ 是问题的规模。
    
    \item 大规模问题的答案可以由小规模问题的答案递推得到，也就是说 $f(n)$ 的值可以由 $\{f(i)|i<n\}$ 中的个别求得。
\end{itemize}

那么如何应用动态规划呢？可以将动态规划拆分成三个子目标：

\begin{enumerate}[itemindent=2em]
    \item 建立状态转移方程。当做已经知道的值$\{f(1),f(2), \cdots, f(n-1)\}$，然后想办法利用它们求得$f(n)$。
    
    \item 缓存并复用以往结果。这一步不难，但是很重要。如果没有合适地处理，很有可能就是指数和线性时间复杂度的区别。

    \item 按顺序从小往大算。这里的“小”和“大”对应的是问题的规模，在这里也就是我们要从 $f(1), f(2), \cdots, $ 到 $f(n)$ 依次顺序计算。
\end{enumerate}

%\printbibliography
\bibliography{../ref}
\bibliographystyle{IEEEtran}
\end{document}
